"""
Report Generation Utilities for PIMS (Parliament IT Inventory Management System)
Bangladesh Parliament Secretariat

This module provides utilities for generating various report formats including:
- PDF reports using ReportLab
- Excel reports using OpenPyXL
- CSV exports with proper formatting
- Common report templates and styling

Location: pims/utils/reports.py
Author: PIMS Development Team
"""

import io
import csv
from datetime import datetime, date
from decimal import Decimal

# Django imports
from django.http import HttpResponse
from django.utils import timezone
from django.template.loader import get_template
from django.conf import settings

# Third-party imports
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side, NamedStyle
from openpyxl.utils import get_column_letter
from openpyxl.chart import BarChart, PieChart, LineChart, Reference
from openpyxl.drawing.image import Image as XLImage

from reportlab.lib.pagesizes import A4, letter, landscape
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle,
    PageBreak, Image, Frame, PageTemplate
)
from reportlab.graphics.shapes import Drawing
from reportlab.graphics.charts.barcharts import VerticalBarChart, HorizontalBarChart
from reportlab.graphics.charts.piecharts import Pie
from reportlab.graphics.charts.linecharts import HorizontalLineChart
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT


class PIIMSReportGenerator:
    """Base report generator class with common functionality."""
    
    def __init__(self):
        self.title = "PIMS Report"
        self.subtitle = "Bangladesh Parliament Secretariat"
        self.author = "PIMS System"
        self.created_date = timezone.now()
    
    def set_report_info(self, title=None, subtitle=None, author=None):
        """Set report metadata."""
        if title:
            self.title = title
        if subtitle:
            self.subtitle = subtitle
        if author:
            self.author = author


class AssignmentReportGenerator(PIIMSReportGenerator):
    """Generator for assignment reports."""
    
    def generate_pdf_report(self, assignments, filters=None, request_user=None):
        """Generate comprehensive PDF assignment report."""
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(
            buffer, 
            pagesize=A4,
            topMargin=2*cm,
            bottomMargin=2*cm,
            leftMargin=2*cm,
            rightMargin=2*cm
        )
        
        elements = []
        styles = getSampleStyleSheet()
        
        # Custom styles
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Title'],
            fontSize=18,
            spaceAfter=30,
            alignment=TA_CENTER,
            textColor=colors.HexColor('#1e3a8a')
        )
        
        subtitle_style = ParagraphStyle(
            'CustomSubtitle',
            parent=styles['Normal'],
            fontSize=12,
            spaceAfter=20,
            alignment=TA_CENTER,
            textColor=colors.HexColor('#64748b')
        )
        
        # Header
        elements.append(Paragraph(self.title, title_style))
        elements.append(Paragraph(self.subtitle, subtitle_style))
        elements.append(Spacer(1, 20))
        
        # Report information
        info_data = [
            ['Report Generated:', self.created_date.strftime('%Y-%m-%d %H:%M:%S')],
            ['Generated by:', request_user.get_full_name() if request_user else 'System'],
            ['Total Records:', str(assignments.count())],
        ]
        
        if filters:
            filter_info = []
            if filters.get('status'):
                filter_info.append(f"Status: {', '.join(filters['status'])}")
            if filters.get('assignment_type'):
                filter_info.append(f"Type: {', '.join(filters['assignment_type'])}")
            if filters.get('date_from') or filters.get('date_to'):
                date_range = f"Date: {filters.get('date_from', 'All')} to {filters.get('date_to', 'All')}"
                filter_info.append(date_range)
            
            if filter_info:
                info_data.append(['Filters Applied:', ' | '.join(filter_info)])
        
        info_table = Table(info_data, colWidths=[3*cm, 12*cm])
        info_table.setStyle(TableStyle([
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#374151')),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ]))
        
        elements.append(info_table)
        elements.append(Spacer(1, 30))
        
        # Statistics summary
        stats = self._get_assignment_statistics(assignments)
        
        elements.append(Paragraph("<b>Assignment Statistics</b>", styles['Heading2']))
        elements.append(Spacer(1, 10))
        
        stats_data = [
            ['Total Assignments', str(stats['total'])],
            ['Active Assignments', str(stats['active'])],
            ['Returned Assignments', str(stats['returned'])],
            ['Overdue Assignments', str(stats['overdue'])],
            ['Temporary Assignments', str(stats['temporary'])],
            ['Permanent Assignments', str(stats['permanent'])],
        ]
        
        stats_table = Table(stats_data, colWidths=[8*cm, 4*cm])
        stats_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#f8fafc')),
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#e2e8f0')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ]))
        
        elements.append(stats_table)
        elements.append(Spacer(1, 30))
        
        # Assignment details table
        elements.append(Paragraph("<b>Assignment Details</b>", styles['Heading2']))
        elements.append(Spacer(1, 10))
        
        # Limit assignments for PDF readability
        assignment_list = assignments[:50]
        
        table_data = [
            ['Assignment ID', 'Device', 'Employee', 'Status', 'Assigned Date', 'Days']
        ]
        
        for assignment in assignment_list:
            table_data.append([
                assignment.assignment_id,
                f"{assignment.device.device_id}" if assignment.device else 'N/A',
                assignment.assigned_to.get_full_name()[:20] if assignment.assigned_to else 'N/A',
                assignment.get_status_display(),
                assignment.assigned_date.strftime('%Y-%m-%d'),
                str(assignment.days_assigned())
            ])
        
        if assignments.count() > 50:
            table_data.append([
                f'... and {assignments.count() - 50} more records',
                '', '', '', '', ''
            ])
        
        assignment_table = Table(table_data, colWidths=[3*cm, 3.5*cm, 3.5*cm, 2*cm, 2.5*cm, 1.5*cm])
        assignment_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1e3a8a')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('FONTSIZE', (0, 1), (-1, -1), 9),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#f8fafc')),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#cbd5e1')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f8fafc')])
        ]))
        
        elements.append(assignment_table)
        
        # Build PDF
        doc.build(elements)
        
        pdf = buffer.getvalue()
        buffer.close()
        
        return pdf
    
    def generate_excel_report(self, assignments, filters=None, request_user=None):
        """Generate comprehensive Excel assignment report."""
        wb = Workbook()
        wb.remove(wb.active)
        
        # Define styles
        header_style = NamedStyle(name="header")
        header_style.font = Font(bold=True, color="FFFFFF")
        header_style.fill = PatternFill(start_color="1e3a8a", end_color="1e3a8a", fill_type="solid")
        header_style.alignment = Alignment(horizontal="center", vertical="center")
        
        title_style = NamedStyle(name="title")
        title_style.font = Font(bold=True, size=16, color="1e3a8a")
        title_style.alignment = Alignment(horizontal="center")
        
        # Summary Sheet
        ws_summary = wb.create_sheet(title="Summary", index=0)
        
        # Title and metadata
        ws_summary['A1'] = self.title
        ws_summary['A1'].style = title_style
        ws_summary.merge_cells('A1:F1')
        
        ws_summary['A3'] = f"Generated: {self.created_date.strftime('%Y-%m-%d %H:%M:%S')}"
        ws_summary['A4'] = f"Generated by: {request_user.get_full_name() if request_user else 'System'}"
        ws_summary['A5'] = f"Total Records: {assignments.count()}"
        
        # Statistics
        stats = self._get_assignment_statistics(assignments)
        
        ws_summary['A7'] = "Assignment Statistics"
        ws_summary['A7'].font = Font(bold=True, size=14)
        
        stats_data = [
            ['Metric', 'Count'],
            ['Total Assignments', stats['total']],
            ['Active Assignments', stats['active']],
            ['Returned Assignments', stats['returned']],
            ['Overdue Assignments', stats['overdue']],
            ['Temporary Assignments', stats['temporary']],
            ['Permanent Assignments', stats['permanent']],
        ]
        
        for row_num, row_data in enumerate(stats_data, 8):
            for col_num, value in enumerate(row_data, 1):
                cell = ws_summary.cell(row=row_num, column=col_num, value=value)
                if row_num == 8:  # Header row
                    cell.style = header_style
        
        # Auto-adjust column width
        for column in ws_summary.columns:
            max_length = 0
            column = [cell for cell in column]
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = (max_length + 2) * 1.2
            ws_summary.column_dimensions[get_column_letter(column[0].column)].width = adjusted_width
        
        # Detailed Data Sheet
        ws_data = wb.create_sheet(title="Assignment Details")
        
        headers = [
            'Assignment ID', 'Device ID', 'Device Name', 'Device Brand', 'Device Model',
            'Employee Name', 'Employee ID', 'Location', 'Assignment Type', 'Status',
            'Assigned Date', 'Expected Return Date', 'Actual Return Date',
            'Purpose', 'Days Assigned', 'Condition at Assignment', 'Condition at Return',
            'Assigned By'
        ]
        
        # Write headers
        for col, header in enumerate(headers, 1):
            cell = ws_data.cell(row=1, column=col, value=header)
            cell.style = header_style
        
        # Write data
        for row, assignment in enumerate(assignments, 2):
            export_data = assignment.get_export_data()
            
            ws_data.cell(row=row, column=1, value=export_data['assignment_id'])
            ws_data.cell(row=row, column=2, value=export_data['device_id'])
            ws_data.cell(row=row, column=3, value=export_data['device_name'])
            ws_data.cell(row=row, column=4, value=export_data['device_brand'])
            ws_data.cell(row=row, column=5, value=export_data['device_model'])
            ws_data.cell(row=row, column=6, value=export_data['employee_name'])
            ws_data.cell(row=row, column=7, value=export_data['employee_id'])
            ws_data.cell(row=row, column=8, value=export_data['location_name'])
            ws_data.cell(row=row, column=9, value=export_data['assignment_type'])
            ws_data.cell(row=row, column=10, value=export_data['status'])
            ws_data.cell(row=row, column=11, value=export_data['assigned_date'])
            ws_data.cell(row=row, column=12, value=export_data['expected_return_date'])
            ws_data.cell(row=row, column=13, value=export_data['actual_return_date'])
            ws_data.cell(row=row, column=14, value=export_data['purpose'])
            ws_data.cell(row=row, column=15, value=export_data['days_assigned'])
            ws_data.cell(row=row, column=16, value=export_data['condition_at_assignment'])
            ws_data.cell(row=row, column=17, value=export_data['condition_at_return'])
            ws_data.cell(row=row, column=18, value=export_data['assigned_by'])
        
        # Auto-adjust column widths
        for column in ws_data.columns:
            max_length = 0
            column = [cell for cell in column]
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min((max_length + 2) * 1.2, 50)  # Cap at 50
            ws_data.column_dimensions[get_column_letter(column[0].column)].width = adjusted_width
        
        # Charts Sheet (if needed)
        if assignments.count() > 0:
            ws_charts = wb.create_sheet(title="Charts")
            
            # Status distribution chart
            status_data = {}
            for assignment in assignments:
                status = assignment.get_status_display()
                status_data[status] = status_data.get(status, 0) + 1
            
            # Create chart data
            chart_start_row = 2
            ws_charts['A1'] = "Status Distribution"
            ws_charts['A1'].font = Font(bold=True, size=14)
            
            for i, (status, count) in enumerate(status_data.items(), chart_start_row):
                ws_charts.cell(row=i, column=1, value=status)
                ws_charts.cell(row=i, column=2, value=count)
            
            # Create pie chart
            pie = PieChart()
            labels = Reference(ws_charts, min_col=1, min_row=chart_start_row, max_row=chart_start_row + len(status_data) - 1)
            data = Reference(ws_charts, min_col=2, min_row=chart_start_row, max_row=chart_start_row + len(status_data) - 1)
            pie.add_data(data)
            pie.set_categories(labels)
            pie.title = "Assignment Status Distribution"
            
            ws_charts.add_chart(pie, "D2")
        
        # Save to BytesIO
        excel_buffer = io.BytesIO()
        wb.save(excel_buffer)
        excel_buffer.seek(0)
        
        return excel_buffer.getvalue()
    
    def _get_assignment_statistics(self, assignments):
        """Get assignment statistics for reports."""
        from django.db.models import Count, Q
        
        total = assignments.count()
        active = assignments.filter(status='ACTIVE').count()
        returned = assignments.filter(status='RETURNED').count()
        overdue = assignments.filter(
            status='ACTIVE',
            expected_return_date__lt=timezone.now().date()
        ).count()
        temporary = assignments.filter(assignment_type='TEMPORARY').count()
        permanent = assignments.filter(assignment_type='PERMANENT').count()
        
        return {
            'total': total,
            'active': active,
            'returned': returned,
            'overdue': overdue,
            'temporary': temporary,
            'permanent': permanent
        }


class DeviceReportGenerator(PIIMSReportGenerator):
    """Generator for device reports."""
    
    def generate_inventory_pdf(self, devices, request_user=None):
        """Generate device inventory PDF report."""
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4)
        elements = []
        styles = getSampleStyleSheet()
        
        # Title
        title = Paragraph("Device Inventory Report", styles['Title'])
        elements.append(title)
        elements.append(Spacer(1, 20))
        
        # Report info
        elements.append(Paragraph(f"Generated: {timezone.now().strftime('%Y-%m-%d %H:%M')}", styles['Normal']))
        elements.append(Paragraph(f"Total Devices: {devices.count()}", styles['Normal']))
        elements.append(Spacer(1, 20))
        
        # Device table
        table_data = [['Device ID', 'Name', 'Brand', 'Model', 'Status', 'Purchase Date']]
        
        for device in devices[:100]:  # Limit for PDF
            table_data.append([
                device.device_id,
                device.name[:20],
                device.brand[:15],
                device.model[:15],
                device.get_status_display(),
                device.purchase_date.strftime('%Y-%m-%d') if device.purchase_date else 'N/A'
            ])
        
        device_table = Table(table_data)
        device_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        elements.append(device_table)
        doc.build(elements)
        
        pdf = buffer.getvalue()
        buffer.close()
        
        return pdf


# Utility functions
def create_csv_response(filename, headers, data):
    """Create CSV HTTP response."""
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    writer = csv.writer(response)
    writer.writerow(headers)
    
    for row in data:
        writer.writerow(row)
    
    return response


def create_pdf_response(pdf_content, filename):
    """Create PDF HTTP response."""
    response = HttpResponse(pdf_content, content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    return response


def create_excel_response(excel_content, filename):
    """Create Excel HTTP response."""
    response = HttpResponse(
        excel_content,
        content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    return response